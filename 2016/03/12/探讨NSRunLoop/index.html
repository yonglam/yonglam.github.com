<!DOCTYPE html><html lang="en"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description"><title>探讨NSRunLoop | No Fish · Blog</title><link rel="stylesheet" type="text/css" href="/css/normalize.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/pure-min.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/grids-responsive-min.css?v=0.0.0"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">探讨NSRunLoop</h1><a id="logo" href="/.">No Fish · Blog</a><p class="description">Coding &amp; Thinking &amp; Writing</p></div><div id="nav-menu"><a href="/." class="current"><i class="icon-home"> Home</i></a><a href="/archives/"><i class="icon-archive"> Archive</i></a><a href="/about/"><i class="icon-about"> About</i></a><a href="/atom.xml"><i class="icon-rss"> RSS</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post post-page"><h1 class="post-title">探讨NSRunLoop</h1><div class="post-meta">2016-03-12</div><span data-thread-key="2016/03/12/探讨NSRunLoop/" class="ds-thread-count"></span><div class="post-content"><p>最近看了Mike Ash的一篇文章《NSRunLoop Internals》，觉得对于理解Runloop很有帮助，所以尝试翻译出来。文章最后一段实在看不懂，觉得对全篇也无甚影响，故略去。其他现翻译如下：</p>
<p>如果你想尽可能透彻地理解一个东西，你应该自己把它实现一次。构建一个完整的NSRunLoop工作量可能有点大，所以我们不会实现一个完整的NSRunLoop，我会使用伪代码实现它的主要功能。</p>
<p><strong>CoreFoundation</strong></p>
<p>在Mac上，NSRunLoop是在CoreFoundation中CFRunLoop的基础上实现的。前者是对后者在Cocoa的一个封装。这次讨论，我将忽略这个结构，把NSRunLoop直接当作入口。从这个角度来看，CFRunLoop就是其具体实现了。</p>
<p><strong>Autorelease Pools</strong></p>
<p>管理Autorelease Pools是NSRunLoop的一个基本功能。管理的范围包括它自已产生的和它所调用的。因为这部分相对比较直观，并会使讨论变复杂，所以我将忽略这一部分的实现。</p>
<p><strong>Fundamentals</strong></p>
<p>NSRunLoop最神秘的地方想必就是各种run方法。里面到底有什么？它又是如何工作的呢？</p>
<p><code>-run</code>方法非常简单，官方文档如下描述：</p>
<p>如果没有input sources或者timers依附在这个runloop上，那这个方法会直接返回。否则，它会使用一个循环，一直调用<code>-runMode:beforeDate:</code>，让自己一直运行在<code>NSDefaultRunLoopMode</code>。</p>
<p>其实现大致是：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)run</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>([<span class="keyword">self</span> hasSourcesOrTimers])</span><br><span class="line">        [<span class="keyword">self</span> runMode: <span class="built_in">NSDefaultRunLoopMode</span> beforeDate: [<span class="built_in">NSDate</span> distantFuture]];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>-runUntilDate:</code>方法也是类似的：</p>
<p>如果没有input sources或者times，那就立即退出。否则它会一直调用<code>-runMode:beforeDate:</code>让自己运行在<code>NSDefaultMode</code>直到超过了指定的时间。</p>
<p>其实现大致是：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)runUntilDate: (<span class="built_in">NSDate</span> *)limitDate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>([<span class="keyword">self</span> hasSourcesOrTimers])</span><br><span class="line">    &#123;</span><br><span class="line">        [<span class="keyword">self</span> runMode: <span class="built_in">NSDefaultRunLoopMode</span> beforeDate: limitDate];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// check limitDate at the end of the loop to ensure that</span></span><br><span class="line">        <span class="comment">// the runloop always runs at least once</span></span><br><span class="line">        <span class="keyword">if</span>([limitDate timeIntervalSinceNow] &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Input Sources</strong></p>
<p>在苹果的《Apple’s Run Loops programming guide》中，一个runloop包含两种类型的源：inputs和timers。Input source是指runloop外部发生的一些信号。</p>
<p>在Mac OS X，inputs sources就是mach ports。NSFileHandle和CFFileDescriptor给人一种印象：它们把非mach port的东西连接到了runloop上。这是错误的。文件描述符的源会被一个另外一个线程监视着，然后通过mach port发信号给runloop。</p>
<p>大部分人听到mach ports眼睛都会闪一下。他们不是很流行，也没有很好的文档说明。而且就个人来说，我也不是很熟悉。因此，我会使用file descriptors来做为runloop的输入源。我们基础的东西都是相同的，只是file descriptor对于大部分人都比较好理解。</p>
<p>什么是file descriptor(FD)？它是一个你可以对它进入读取、写入或者同时读写的对象（不是Objc中的对象）。一个FD可以有数据以供读取，或者空间以供写入，或者什么都没有。FD的这种状态一直在变化。比如，想像有一个FD是表示一个与另一个应用通讯的socket。当另一个应用向socket写入数据时，这个FD就会有数据可读了。如果这个FD是某个runloop的input source，那这个runloop就会被唤醒来处理这个input source。类似的，当另一个应用从socket读取数据，在你的应用中，FD就有可用的空间了，而这会唤醒对应的runloop来处理。而这些正是runloop的一个基本功能。</p>
<p>Runloop需要同时监视多个input sources。在OS X上有很多API可以做这事，这里我选择了<code>select</code>。</p>
<p>我将详细介绍怎样使用select。基本是非常简单的：把3个FD的set传给它，这些FD是你想要监控读、写和错误的。一旦有事件发生，它就会return，并且3个set中会存放发生了相应事件的FD。</p>
<p>为了简化，我们会把3个set改为1个。我们只是关心这些FD的事件。还有，我现在用的是伪代码，所以看上去不是100%的objc。</p>
<p>第一件事就是检查有没有任何source。根据文档，如果没有source，就会立即return NO。</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)runMode: (<span class="built_in">NSString</span> *)mode beforeDate: (<span class="built_in">NSDate</span> *)limitDate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(![<span class="keyword">self</span> hasSourcesOrTimers])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br></pre></td></tr></table></figure>
<p>下一步，我们创建一个空的FD set：</p>
<figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">fd_set fdset<span class="comment">;</span></span><br><span class="line">    FD_ZERO(&amp;fdset)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>然后，我们把每一个input source的FD放到这个set里面。我们假设input source有一个方法<code>-fileDescriptor</code>会返回相应的FD：</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for<span class="list">(<span class="keyword">inputSource</span> in [self inputSources])</span></span><br><span class="line">	FD_SET<span class="list">([inputSource fileDescriptor], <span class="keyword">&amp;fdset</span>)</span><span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>现在我们来调用select。记住，为了简化，我们假设它只使用一个set而不是三个。同样，我会忽略错误检查。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">select</span><span class="params">(fdset, NULL)</span></span></span><br></pre></td></tr></table></figure>
<p>一旦返回，我们检查每一个input source来看看是否已经可以处理了。我们先拷贝一份input source，因为input source所处的环境可能会对它进行修改。然后对input source进行遍历：</p>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">for</span>(inputSource in <span class="attr_selector">[[[self inputSources]</span> copy] autorelease])</span><br><span class="line">        <span class="function">if</span>(<span class="function">FD_ISSET</span>(<span class="attr_selector">[inputSource fileDescrptor]</span>, &amp;fdset))</span><br><span class="line">            <span class="attr_selector">[inputSource fileDescriptorIsReady]</span>;</span><br></pre></td></tr></table></figure>
<p>文档声明只要runloop有运行过，就返回YES。所以最后要做的事就是：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Modes</strong></p>
<p>到目前一切还算顺利，但还有一个问题。这个方法完全忽略了它的参数。首先，让我们看看第一个参数：mode。</p>
<p>参数mode有什么意义？一个mode其实就是一个input和timer sources的集合。不同的source运行在不同的mode中。NSRunLoop有一个NSDefaultRunLoopMode，从名字上看，大部分的source都会被加到里面。在Cocoa中，你也有第二个mode:NSEventTrackingRunLoopMode，当鼠标在控件上按下的时候就会被运行。转换到这个Mode，只被添加到default mode的source就不会被触发，这样可以防止在用户进行界面操作时执行其他没必要的代码。需要在系统跟踪事件时就触发的source就需要添加到这个mode。需要在两个mode中触发的source可以同时添加到两个mode中。</p>
<p>你可以想像NSRunLoop有一个这样的变量：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maps modes to NSMutableSets</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *_inputSources;</span><br></pre></td></tr></table></figure>
<p>NSRunLoop有一个方法来把input source添加到mode中，其实现大约如下：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>)<span class="string">addPort:</span> (NSPort *)aPort <span class="string">forMode:</span> (NSString *)mode</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableSet *sourcesSet = [_inputSources <span class="string">objectForKey:</span> mode];</span><br><span class="line">    <span class="keyword">if</span>(!sourcesSet)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// this is the first time anything has used this mode</span></span><br><span class="line">        <span class="comment">// so create a new set for it</span></span><br><span class="line">        sourcesSet = [NSMutableSet set];</span><br><span class="line">        [_inputSources <span class="string">setObject:</span> sourcesSet <span class="string">forKey:</span> mode];</span><br><span class="line">    &#125;</span><br><span class="line">    [sourcesSet <span class="string">addObject:</span> aPort];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除的方法类似：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="typename">void</span>)<span class="string">removePort:</span> (NSPort *)aPort <span class="string">forMode:</span> (NSString *)mode</span><br><span class="line">&#123;</span><br><span class="line">    NSMutableSet *sourcesSet = [_inputSources <span class="string">objectForKey:</span> mode];</span><br><span class="line">    [sourcesSet <span class="string">removeObject:</span> aPort];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// this isn't strictly necessary, but keeps us from leaking</span></span><br><span class="line">    <span class="comment">// sets if the caller uses a lot of one-time "throwaway" modes</span></span><br><span class="line">    <span class="comment">// (which it probably never would)</span></span><br><span class="line">    <span class="keyword">if</span>(![sourcesSet count])</span><br><span class="line">        [_inputSources <span class="string">removeObjectForKey:</span> mode];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同时，我们的run方法也要做修改：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)runMode: (<span class="built_in">NSString</span> *)mode beforeDate: (<span class="built_in">NSDate</span> *)limitDate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(![<span class="keyword">self</span> hasSourcesOrTimersForMode: mode])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    fd_set fdset;</span><br><span class="line">    FD_ZERO(&amp;fdset);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(inputSource <span class="keyword">in</span> [_inputSources objectForKey: mode])</span><br><span class="line">        FD_SET([inputSource fileDescriptor], &amp;fdset);</span><br><span class="line">    </span><br><span class="line">    select(fdset, <span class="literal">NULL</span>);</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">for</span>(inputSource <span class="keyword">in</span> [[[_inputSources objectForKey: mode] <span class="keyword">copy</span>] autorelease])</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET([inputSource fileDescrptor], &amp;fdset))</span><br><span class="line">            [inputSource fileDescriptorIsReady];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Timeout</strong></p>
<p>上面的代码也忽略了第二个参数：limitDate。如果这个参数指定的时间到了，而没有input srouce被触发，那run方法也会被强制退出。它就是用于做为超时限制。为了实现这个功能，我们只需要简单计算超时时间，并把它作为最后一个参数传给select（在现实中，这需要一个复杂的结构体，不仅仅是一个NSTimeInterval，但请记住我们是使用伪代码）：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> - (<span class="built_in">BOOL</span>)runMode: (<span class="built_in">NSString</span> *)mode beforeDate: (<span class="built_in">NSDate</span> *)limitDate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(![<span class="keyword">self</span> hasSourcesOrTimersForMode: mode])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    fd_set fdset;</span><br><span class="line">    FD_ZERO(&amp;fdset);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(inputSource <span class="keyword">in</span> [_inputSources objectForKey: mode])</span><br><span class="line">        FD_SET([inputSource fileDescriptor], &amp;fdset);</span><br><span class="line">             <span class="built_in">NSTimeInterval</span> timeout = [limitDate timeIntervalSinceNow];</span><br><span class="line">    select(fdset, timeout);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// if the timeout was hit, there may not be</span></span><br><span class="line">    <span class="comment">// any active input sources, but this loop</span></span><br><span class="line">    <span class="comment">// will simply do nothing if that's the case</span></span><br><span class="line">    <span class="keyword">for</span>(inputSource <span class="keyword">in</span> [[[_inputSources objectForKey: mode] <span class="keyword">copy</span>] autorelease])</span><br><span class="line">        <span class="keyword">if</span>(FD_ISSET([inputSource fileDescrptor], &amp;fdset))</span><br><span class="line">            [inputSource fileDescriptorIsReady];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Timer Sources</strong><br> 上面的实现处理了input sources和timeout参数，但完全忽略了timer。</p>
<p> 和input source一样，我们假设有一个变量来保存timer，而timer也按mode进行分组：</p>
 <figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// maps modes to NSMutableSets</span></span><br><span class="line"><span class="built_in">NSMutableDictionary</span> *_timerSources;</span><br></pre></td></tr></table></figure>
<p>我会跳过<code>-addTimer:forMode:</code>的实现，因为其实现比较简单，且基本同<code>-addPort:forMode:</code>是一样的。</p>
<p>在上面的代码中添加timer的支持比较直接。我们在timer列表中查找出最近会被fire的timer。如果它的触发时间比limitDate早，那么这个时间会被当作超时时间（代替limitDate）。当select返回后，我们检查timer列表，看看是否有timer已经可以触发，如果有，我们就触发它们。</p>
<p>有一个技巧点：timer的触发不会导致方法的返回。如果有一个timer到期了，那处理完它之后，要把控制权再次交给select。这将一直进行到有input source触发。如果有input source触发，还是需要检查timer的列表，触发需要被触发的timer。</p>
<p>根据上面的分析， 代码如下：</p>
<figure class="highlight objectivec"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">BOOL</span>)runMode: (<span class="built_in">NSString</span> *)mode beforeDate: (<span class="built_in">NSDate</span> *)limitDate</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(![<span class="keyword">self</span> hasSourcesOrTimersForMode: mode])</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// with timer support, this code has to loop until an input</span></span><br><span class="line">    <span class="comment">// source fires</span></span><br><span class="line">    <span class="built_in">BOOL</span> didFireInputSource = <span class="literal">NO</span>;</span><br><span class="line">    <span class="keyword">while</span>(!didFireInputSource)</span><br><span class="line">    &#123;</span><br><span class="line">        fd_set fdset;</span><br><span class="line">        FD_ZERO(&amp;fdset);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(inputSource <span class="keyword">in</span> [_inputSources objectForKey: mode])</span><br><span class="line">            FD_SET([inputSource fileDescriptor], &amp;fdset);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// the timeout needs to be set from the limitDate</span></span><br><span class="line">        <span class="comment">// and from the list of timers</span></span><br><span class="line">        <span class="comment">// start with the limitDate</span></span><br><span class="line">        <span class="built_in">NSTimeInterval</span> timeout = [limitDate timeIntervalSinceNow];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// now run through the list of timers and set the</span></span><br><span class="line">        <span class="comment">// timeout to the smallest one found in them and</span></span><br><span class="line">        <span class="comment">// in the limitDate</span></span><br><span class="line">        <span class="keyword">for</span>(timer <span class="keyword">in</span> [_timerSources objectForKey: mode])</span><br><span class="line">            timeout = MIN(timeout, [[timer fireDate] timeIntervalSinceNow]);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// now run select</span></span><br><span class="line">        select(fdset, timeout);</span><br><span class="line">        <span class="comment">// process input sources first (this choice is arbitrary)</span></span><br><span class="line">        <span class="keyword">for</span>(inputSource <span class="keyword">in</span> [[[_inputSources objectForKey: mode] <span class="keyword">copy</span>] autorelease])</span><br><span class="line">            <span class="keyword">if</span>(FD_ISSET([inputSource fileDescrptor], &amp;fdset))</span><br><span class="line">            &#123;</span><br><span class="line">                didFireInputSource = <span class="literal">YES</span>;</span><br><span class="line">                [inputSource fileDescriptorIsReady];</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// now process timers</span></span><br><span class="line">        <span class="comment">// responsibility for updating fireDate for repeating timers</span></span><br><span class="line">        <span class="comment">// and for removing the timer from the runloop for non-repeating timers</span></span><br><span class="line">        <span class="comment">// rests in the timer class, not in the runloop</span></span><br><span class="line">        <span class="keyword">for</span>(timer <span class="keyword">in</span> [[[_timerSources objectForKey: mode] <span class="keyword">copy</span>] autorelease])</span><br><span class="line">            <span class="keyword">if</span>([[timer fireDate] timeIntervalSinceNow] &lt;= <span class="number">0</span>)</span><br><span class="line">                [timer fire];</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// see if we timed out, if so, abort!</span></span><br><span class="line">        <span class="comment">// this is checked at the end to ensure that timers and inputs are</span></span><br><span class="line">        <span class="comment">// always processed at least once before returning</span></span><br><span class="line">        <span class="keyword">if</span>([limitDate timeIntervalSinceNow] &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码实现了所有必要的功能。最后的代码简单而易懂。</p>
<p><strong>Conclusion</strong></p>
<p>这个练习告诉了我们什么？我们要小心这个伪代码和苹果的实现不是完全吻合的。事实上，最近我发现一点不同：苹果的实现在每个runloop只会触发一个到期的timer，而我们的实现是会在一个runloop中触发所有到期的timer。还有一个最大的不同：苹果使用的是mach ports而我们使用文件描述符。</p>
<p>尽管如此，在这类练习中，我们还是可以学到很多东西。比如，runloop mode是一个几乎所有Cocoa程序员容易困惑的概念，通过写出这些伪代码，我们弄清楚了什么是mode，以及它是如何工作的。</p>
<p>它也可以帮助我们推荐其他一些Cocoa组件是怎么工作的。比如，我们可以推理<code>-performSelector:withObject:afterDelay:</code>的内部工作方法。因为一个runloop只处理input source和timer，它的实现一定使用了两者之一。因为它是在一定的时间之后触发的，它肯定是使用了timer技术。通过debuger看它是怎么运行的，可以证明我们的推论。另一个例子，<code>-performSelectorOnMainThread:withObject:waitUntilDone:</code>一定使用了mach port，因为不可能在一个子线程中操作一个在主线程中的timer。</p>
<p>总而言之，这类技术真的很有用。我通常不会像今天这样写伪代码，但思考一下苹果代码是怎么实现的，有助于我们更好的理解它是如何工作的以及文档说的是什么、暗示了什么。你要保证你的推理是基于文档说明和现实的限制，而不是自己的臆想。</p>
</div><div class="tags"></div><div class="post-nav"><a href="/2016/02/16/为UIControl实现安全的addTarget/" class="next">为UIControl实现安全的addTarget<i class="icon-next"></i></a></div><div data-thread-key="2016/03/12/探讨NSRunLoop/" data-title="探讨NSRunLoop" data-url="http://yonglam.github.com/2016/03/12/探讨NSRunLoop/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div data-thread-key="2016/03/12/探讨NSRunLoop/" data-title="探讨NSRunLoop" data-url="http://yonglam.github.com/2016/03/12/探讨NSRunLoop/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4"><div id="sidebar"><div class="widget"><div class="widget-title">Categories</div></div><div class="widget"><div class="widget-title">Tags</div><div class="tagcloud"></div></div><div class="widget"><div class="widget-title">Recent</div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2016/03/12/探讨NSRunLoop/">探讨NSRunLoop</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/16/为UIControl实现安全的addTarget/">为UIControl实现安全的addTarget</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/02/04/加密-签名/">加密&签名</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/31/Xcode-Plugin-Development/">Xcode Plugin Development</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/27/Security-in-iOS/">Security in iOS</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/18/使用NSBlockOperation实现异步多任务/">使用NSBlockOperation实现异步多任务</a></li><li class="post-list-item"><a class="post-list-link" href="/2016/01/17/Weak-Array-in-Obj-C/">Weak Array in Obj-C</a></li><li class="post-list-item"><a class="post-list-link" href="/2015/08/28/hello-world/">Hello World</a></li></ul></div><div class="widget"><div class="comments-title">Recent Comments</div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title">Blogroll</div><ul></ul><a href="https://github.com/yonglam" title="My Github" target="_blank">My Github</a></div></div></div></div><div id="footer">© <a href="/." rel="nofollow">No Fish · Blog.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/jquery.min.js?v=0.0.0"></script><script type="text/javascript" src="/js/totop.js?v=0.0.0"></script><script type="text/javascript" src="/js/fancybox.pack.js?v=0.0.0"></script><script type="text/javascript" src="/js/jquery.fancybox.js?v=0.0.0"></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'yonglam'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>